<style>
    .util-container { font-family: -apple-system, sans-serif; color: var(--text-color); }
    .util-section { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
    
    .util-btn {
        width: 100%;
        padding: 12px;
        margin: 5px 0;
        border-radius: 8px;
        border: none;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: opacity 0.2s;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 8px;
    }
    .util-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .btn-backup { background-color: #24292e; color: white; }
    .btn-restore { background-color: #28a745; color: white; }
    .btn-save { background-color: #007bff; color: white; }
    .btn-warn { background-color: #ffc107; color: #333; }
    .btn-danger { background-color: #dc3545; color: white; }
    .btn-info { background-color: #17a2b8; color: white; }

    .input-field {
        width: 100%;
        padding: 10px;
        margin: 5px 0;
        border-radius: 6px;
        border: 1px solid #ccc;
        box-sizing: border-box;
    }
    
    .status-log {
        background: rgba(0,0,0,0.05);
        padding: 10px;
        border-radius: 6px;
        font-family: monospace;
        font-size: 12px;
        min-height: 60px;
        max-height: 150px;
        overflow-y: auto;
        margin-top: 10px;
    }
    .log-entry { border-bottom: 1px solid #ddd; padding: 5px 0; }
    .log-entry.error { color: #dc3545; }
</style>

<div class="util-container">

    <div class="util-section">
        <h3>üîë Configuration</h3>
        <p style="font-size: 0.9em; color: #666;">Enter GitHub PAT for cloud backups.</p>
        <input type="password" id="gh-token-input" class="input-field" placeholder="github_pat_...">
        <button id="btn-save-token" class="util-btn btn-save">Save Token</button>
    </div>
    
    <div class="util-section">
        <h3>üì• Data Import</h3>
        <p style="font-size: 0.9em; color: #666;">Upload JSON (words/sentences) or CSV (verbs).</p>
        <input type="file" id="import-file-input" class="input-field" accept=".json,.csv">
        <button id="btn-import-file" class="util-btn btn-save">Import Data</button>
    </div>

    <div class="util-section">
        <h3>‚òÅÔ∏è Unified Cloud Backup</h3>
        <p style="font-size: 0.9em; color: #666;">Backs up <b>BOTH</b> Life Organizer and Spanish Data to GitHub.</p>
        <button id="btn-gh-backup" class="util-btn btn-backup">Backup Everything</button>
        <button id="btn-gh-restore" class="util-btn btn-restore">Restore Everything</button>
    </div>

    <div class="util-section">
        <h3>üßπ Data Management</h3>
        <p style="font-size: 0.9em; color: #666;">Reset specific parts of your database without losing others.</p>
        
        <button id="btn-wipe-spanish" class="util-btn btn-warn">
            <span>üá™üá∏</span> Wipe Spanish Data Only
        </button>
        <button id="btn-wipe-life" class="util-btn btn-warn">
            <span>üìÖ</span> Wipe Life Organizer Only
        </button>
        <button id="btn-wipe-all" class="util-btn btn-danger">
            <span>‚ö†Ô∏è</span> Factory Reset (Wipe All)
        </button>
    </div>

    <div class="util-section">
        <h3>‚ö†Ô∏è Diagnostics & Logs</h3>
        <button id="btn-perf-check" class="util-btn btn-info">Run Performance Check</button>
        <button id="btn-update-widgets" class="util-btn btn-save">Check for Widget Updates</button>
        <div style="height: 10px;"></div>
        <button id="btn-test-error" class="util-btn btn-warn">Trigger Test Error</button>
        <button id="btn-view-logs" class="util-btn btn-info" style="background-color: #17a2b8; color:white;">View System Logs</button>
        <button id="btn-clear-logs" class="util-btn btn-danger">Clear Logs</button>
        
        <div id="backup-log" class="status-log">Ready...</div>
    </div>

</div>

<script>
    (() => {
        // --- DEFINITIONS ---
        const SPANISH_TABLES = ['words', 'sentences', 'myVocabulary', 'verbs', 'activityLog'];
        const LIFE_TABLES = [
            'habits', 'habitHistory', 'tasks', 'taskHistory', 'goals', 'mood', 
            'sobrietyTrackers', 'sobrietyRelapses', 'sobrietyUrges', 
            'financeTransactions', 'financeCategories', 'healthMetrics', 
            'healthTimeSeries', 'sleepLogs', 'nutritionLogs', 'waterLogs', 'history'
        ];
        
        const logEl = document.getElementById('backup-log');
        
        // Config
        const REPO_OWNER = 'dawidofski';
        const REPO_NAME = 'backup';
        const FILE_PATH = 'life_organizer_full_backup.json';
        const API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${FILE_PATH}`;

        // Inputs
        const tokenInput = document.getElementById('gh-token-input');
        const fileInput = document.getElementById('import-file-input');
        
        function log(msg) {
            console.log(msg); // Log to console as well
            const line = document.createElement('div');
            line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logEl.prepend(line);
        }

        // Load Token
        const savedToken = localStorage.getItem('gh_pat');
        if (savedToken) tokenInput.value = savedToken;

        document.getElementById('btn-save-token').onclick = () => {
            if (tokenInput.value.trim()) {
                localStorage.setItem('gh_pat', tokenInput.value.trim());
                log('‚úÖ Token saved.');
            }
        };

        // --- IMPORT HANDLERS ---
        const importBtn = document.getElementById('btn-import-file');
        if (importBtn) {
            importBtn.onclick = () => {
                console.log("Import button clicked");
                if (!fileInput || !fileInput.files.length) {
                    log('‚ö†Ô∏è Please select a .json or .csv file first.');
                    return;
                }

                const file = fileInput.files[0];
                const fileExtension = file.name.split('.').pop().toLowerCase();
                log(`üìñ Reading ${file.name}...`);
                
                if (fileExtension === 'json') {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            processJsonUpload(data);
                        } catch (error) {
                            log(`‚ùå Error parsing JSON: ${error.message}`);
                        }
                    };
                    reader.readAsText(file);
                } else if (fileExtension === 'csv') {
                    if (typeof Papa === 'undefined') {
                        log("‚ùå PapaParse library not loaded. Please refresh.");
                        return;
                    }
                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        transformHeader: (h) => h.toLowerCase(),
                        complete: (results) => processCsvUpload(results.data),
                        error: (err) => log(`‚ùå CSV Error: ${err.message}`)
                    });
                } else {
                    log('‚ùå Unsupported file type. Use .json or .csv');
                }
            };
        }

        async function processJsonUpload(data) {
            let wordsAdded = 0, sentencesAdded = 0;
            let wordsSkipped = 0, sentencesSkipped = 0;

            try {
                // 1. Standard Object Format { "words": [], "sentences": [] }
                if (typeof data === 'object' && !Array.isArray(data) && (data.words || data.sentences)) {
                    if (data.words && Array.isArray(data.words)) {
                        const res = await importStandardWords(data.words);
                        wordsAdded = res.added; wordsSkipped = res.skipped;
                    }
                    if (data.sentences && Array.isArray(data.sentences)) {
                        const res = await importStandardSentences(data.sentences);
                        sentencesAdded = res.added; sentencesSkipped = res.skipped;
                    }
                }
                // 2. Array of Words [ {"a":"eng", "un/una":"spa"} ]
                else if (Array.isArray(data) && data.length > 0 && data[0].a && data[0]['un/una']) {
                    const res = await importNewWordFormat(data);
                    wordsAdded = res.added; wordsSkipped = res.skipped;
                }
                // 3. Array of Sentences [ {"topic": "spanish..."} ]
                else if (Array.isArray(data) && data.length > 0 && data[0].topic) {
                    const res = await importNewSentenceFormat(data);
                    sentencesAdded = res.added; sentencesSkipped = res.skipped;
                } else {
                    log('‚ùå Unknown JSON format.');
                    return;
                }

                log(`‚úÖ Import Done: +${wordsAdded} Words, +${sentencesAdded} Sentences.`);
            } catch (e) {
                log(`‚ùå Import Failed: ${e.message}`);
            }
        }

        async function processCsvUpload(data) {
            if (!data || data.length === 0) { log('‚ùå Empty CSV.'); return; }
            
            // Check for Verb CSV headers
            if (data[0].infinitive !== undefined && data[0].form_1s !== undefined) {
                try {
                    log('‚è≥ Processing Verbs...');
                    const res = await importVerbs(data);
                    log(`‚úÖ Verbs: +${res.added} added.`);
                } catch (e) {
                    log(`‚ùå Verb Import Failed: ${e.message}`);
                }
            } else {
                log('‚ùå CSV missing "infinitive" or "form_1s" columns.');
            }
        }

        // --- IMPORT HELPERS ---
        async function importStandardWords(list) {
            if (!window.db.words) return { added:0, skipped:0 };
            const existing = new Set(await window.db.words.orderBy('spanish').keys());
            const toAdd = list.filter(w => w.spanish && !existing.has(w.spanish))
                .map(w => ({ spanish: w.spanish, english: w.english, learned: 0 }));
            if(toAdd.length) await window.db.words.bulkAdd(toAdd);
            return { added: toAdd.length, skipped: list.length - toAdd.length };
        }

        async function importStandardSentences(list) {
            if (!window.db.sentences) return { added:0, skipped:0 };
            const existing = new Set(await window.db.sentences.orderBy('spanish').keys());
            const toAdd = list.filter(s => s.spanish && !existing.has(s.spanish))
                .map(s => ({ spanish: s.spanish, english: s.english, learned: 0 }));
            if(toAdd.length) await window.db.sentences.bulkAdd(toAdd);
            return { added: toAdd.length, skipped: list.length - toAdd.length };
        }

        async function importNewWordFormat(list) {
            if (!window.db.words) return { added:0, skipped:0 };
            const existing = new Set(await window.db.words.orderBy('spanish').keys());
            const toAdd = [];
            for (const item of list) {
                const spa = item['un/una'];
                if (spa && !existing.has(spa)) {
                    toAdd.push({ spanish: spa, english: item.a, learned: 0 });
                    existing.add(spa);
                }
            }
            if(toAdd.length) await window.db.words.bulkAdd(toAdd);
            return { added: toAdd.length, skipped: list.length - toAdd.length };
        }

        async function importNewSentenceFormat(list) {
            if (!window.db.sentences) return { added:0, skipped:0 };
            const existing = new Set(await window.db.sentences.orderBy('spanish').keys());
            const toAdd = [];
            for (const item of list) {
                const spa = item.topic;
                if (spa && !existing.has(spa)) {
                    toAdd.push({ spanish: spa, english: "", learned: 0 });
                    existing.add(spa);
                }
            }
            if(toAdd.length) await window.db.sentences.bulkAdd(toAdd);
            return { added: toAdd.length, skipped: list.length - toAdd.length };
        }

        async function importVerbs(list) {
            if (!window.db.verbs) return { added:0, skipped:0 };
            // Simple check to avoid re-importing same file
            const count = await window.db.verbs.count();
            if (count > 0 && !confirm(`Verbs table has ${count} entries. Add anyway?`)) {
                return { added: 0, skipped: list.length };
            }

            const toAdd = [];
            const mapping = { 'form_1s':'1s', 'form_2s':'2s', 'form_3s':'3s', 'form_1p':'1p', 'form_2p':'2p', 'form_3p':'3p' };

            for (const row of list) {
                for (const key in mapping) {
                    const person = mapping[key];
                    const form = row[key];
                    if (form && form.trim()) {
                        toAdd.push({
                            infinitive: row.infinitive,
                            mood: row.mood,
                            tense: row.tense,
                            person: person,
                            form: form,
                            learned: 0
                        });
                    }
                }
            }
            if(toAdd.length) await window.db.verbs.bulkAdd(toAdd);
            return { added: toAdd.length, skipped: 0 };
        }

        // --- ERROR & LOGGING HANDLERS ---
        
        document.getElementById('btn-test-error').onclick = () => {
            try {
                throw new Error("This is a manually triggered test error!");
            } catch(e) {
                window.ErrorHandler.logError('Manual Test', e);
                log("‚ö†Ô∏è Error thrown and logged.");
            }
        };

        document.getElementById('btn-view-logs').onclick = async () => {
            logEl.innerHTML = "Loading logs...";
            try {
                if (!window.db.errorLogs) {
                    logEl.innerHTML = "ErrorLogs table not found.";
                    return;
                }
                
                const logs = await window.db.errorLogs.orderBy('timestamp').reverse().limit(20).toArray();
                
                if (logs.length === 0) {
                    logEl.innerHTML = "No system logs found.";
                    return;
                }

                logEl.innerHTML = logs.map(l => `
                    <div class="log-entry error">
                        <strong>${new Date(l.timestamp).toLocaleTimeString()}</strong><br>
                        ${l.message}
                    </div>
                `).join('');
                
            } catch(e) {
                logEl.innerText = "Failed to load logs: " + e.message;
            }
        };

        document.getElementById('btn-clear-logs').onclick = async () => {
            if(confirm("Delete all system logs?")) {
                if (window.db.errorLogs) await window.db.errorLogs.clear();
                logEl.innerHTML = "Logs cleared.";
            }
        };

        // --- WIPE LOGIC ---
        async function wipeTables(tableNames, label) {
            if(!confirm(`Are you sure you want to wipe ALL ${label} data? This cannot be undone.`)) return;
            
            log(`‚è≥ Wiping ${label} data...`);
            try {
                await window.db.transaction('rw', tableNames, async () => {
                    for (const name of tableNames) {
                        if (window.db[name]) {
                            await window.db[name].clear();
                        }
                    }
                });
                log(`‚úÖ ${label} data wiped successfully.`);
            } catch (e) {
                log(`‚ùå Error wiping ${label}: ${e.message}`);
                console.error(e);
            }
        }

        document.getElementById('btn-wipe-spanish').onclick = () => wipeTables(SPANISH_TABLES, "Spanish Learning");
        document.getElementById('btn-wipe-life').onclick = () => wipeTables(LIFE_TABLES, "Life Organizer");
        
        document.getElementById('btn-wipe-all').onclick = async () => {
            if(!confirm("‚ö†Ô∏è FACTORY RESET: This will delete EVERYTHING. Are you sure?")) return;
            await window.db.delete();
            location.reload();
        };

        // --- PERFORMANCE CHECK ---
        document.getElementById('btn-perf-check').onclick = async () => {
            log("‚ö° Running diagnostics...");
            const start = performance.now();
            
            try {
                const ids = await window.db.systemValidation.bulkAdd([
                    { test: 'perf', date: Date.now() },
                    { test: 'perf', date: Date.now() },
                    { test: 'perf', date: Date.now() }
                ]);
                await window.db.systemValidation.where('id').anyOf(ids).toArray();
                await window.db.systemValidation.bulkDelete(ids);
                
                const end = performance.now();
                const duration = (end - start).toFixed(2);
                
                let totalRecords = 0;
                for(const table of window.db.tables) {
                    totalRecords += await table.count();
                }

                log(`‚úÖ Check Passed: ${duration}ms`);
                log(`üìä Total Database Records: ${totalRecords}`);
                log(`üíæ Database Open: OK`);
                
            } catch(e) {
                log(`‚ùå Diagnostics Failed: ${e.message}`);
            }
        };

        // --- BACKUP LOGIC (Unified) ---
        async function exportDB() {
            log('üì¶ Exporting all tables...');
            const data = {};
            await window.db.transaction('r', window.db.tables, async () => {
                for (const table of window.db.tables) {
                    if (table.name !== 'widgetCache') {
                        data[table.name] = await table.toArray();
                    }
                }
            });
            return JSON.stringify(data);
        }

        async function uploadToGitHub(content) {
            const token = localStorage.getItem('gh_pat');
            if (!token) throw new Error("No Token Saved");

            let sha = null;
            try {
                const res = await fetch(API_URL, {
                    headers: { 'Authorization': `token ${token}` }
                });
                if (res.ok) sha = (await res.json()).sha;
            } catch(e) {}

            const body = {
                message: `Unified Backup ${new Date().toISOString()}`,
                content: btoa(unescape(encodeURIComponent(content))),
                sha: sha
            };

            const res = await fetch(API_URL, {
                method: 'PUT',
                headers: {
                    'Authorization': `token ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
            });
            if (!res.ok) throw new Error(`GitHub API: ${res.status}`);
        }

        document.getElementById('btn-gh-backup').onclick = async () => {
            const btn = document.getElementById('btn-gh-backup');
            btn.disabled = true;
            try {
                const json = await exportDB();
                await uploadToGitHub(json);
                log('‚úÖ Unified Backup Saved to GitHub!');
            } catch (e) {
                log('‚ùå Backup Failed: ' + e.message);
            }
            btn.disabled = false;
        };

        document.getElementById('btn-gh-restore').onclick = async () => {
            if(!confirm("Overwrite local data with GitHub backup?")) return;
            const btn = document.getElementById('btn-gh-restore');
            btn.disabled = true;
            try {
                const token = localStorage.getItem('gh_pat');
                if (!token) throw new Error("No Token");

                const res = await fetch(API_URL, {
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3.raw' }
                });
                if (!res.ok) throw new Error('Download failed');
                
                const data = await res.json();
                log('üì• Importing...');
                
                await window.db.transaction('rw', window.db.tables, async () => {
                    for (const table of window.db.tables) {
                        if (table.name !== 'widgetCache') {
                            await table.clear();
                            if (data[table.name]) {
                                await table.bulkAdd(data[table.name]);
                            }
                        }
                    }
                });
                log('‚úÖ Restore Complete. Reloading...');
                setTimeout(() => location.reload(), 1500);
            } catch(e) {
                log('‚ùå Restore Failed: ' + e.message);
            }
            btn.disabled = false;
        };
        
        document.getElementById('btn-update-widgets').onclick = async () => {
             if (window.loader) {
                log('Checking for updates...');
                await window.loader.checkForUpdates(true);
             }
        };

    })();
</script>